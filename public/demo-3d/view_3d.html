<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Model Viewer - GLB</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 100;
        }
        
        button {
            margin: 2px;
            padding: 5px 10px;
            background: #444;
            color: white;
            border: none;
            border-radius: 3px;
            cursor: pointer;
        }
        
        button:hover {
            background: #666;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 20px;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="loading">ƒêang t·∫£i model 3D...</div>
    
    <div id="info">
        <h3>3D Model Viewer</h3>
        <p>File: 1_web.glb</p>
        <p>K√≠ch th∆∞·ªõc: 15.9 MB</p>
    </div>
    
    <div id="controls">
        <h4>ƒêi·ªÅu khi·ªÉn:</h4>
        <button onclick="resetCamera()">Reset Camera</button>
        <button onclick="toggleWireframe()">Wireframe</button>
        <button onclick="toggleAnimation()">Animation</button>
        <br>
        <button onclick="increaseBrightness()">üîÜ S√°ng h∆°n</button>
        <button onclick="decreaseBrightness()">üîÖ T·ªëi h∆°n</button>
        <button onclick="toggleSuperBright()">‚ö° Si√™u s√°ng</button>
        <button onclick="setBlackBackground()">‚ö´ N·ªÅn ƒëen</button>
        <button onclick="setWhiteBackground()">‚ö™ N·ªÅn tr·∫Øng</button>
        <button onclick="setGrayBackground()">üîò N·ªÅn x√°m</button>
        <br>
        <span style="font-size: 12px; color: #ccc;">M√†u v·∫≠t th·ªÉ:</span>
        <button onclick="setModelColor('#ff0000')" style="background: #ff0000;">üî¥</button>
        <button onclick="setModelColor('#00ff00')" style="background: #00ff00;">üü¢</button>
        <button onclick="setModelColor('#0000ff')" style="background: #0000ff;">üîµ</button>
        <button onclick="setModelColor('#ffff00')" style="background: #ffff00;">üü°</button>
        <button onclick="setModelColor('#ff00ff')" style="background: #ff00ff;">üü£</button>
        <button onclick="setModelColor('#00ffff')" style="background: #00ffff;">üîµ</button>
        <button onclick="setModelColor('#ffffff')" style="background: #ffffff; color: #000;">‚ö™</button>
        <button onclick="resetModelColor()">‚Ü∫ G·ªëc</button>
        <br>
        <span style="font-size: 12px; color: #ccc;">Ch·∫ø ƒë·ªô hi·ªÉn th·ªã:</span>
        <button onclick="toggleMatcap()">üåü Matcap</button>
        <button onclick="toggleNormalMap()">üìê Normal</button>
        <button onclick="enhanceContrast()">‚ö° T∆∞∆°ng ph·∫£n</button>
        <button onclick="toggleDepthShading()">üé≠ Depth</button>
        <br>
        <small>
            ‚Ä¢ Chu·ªôt tr√°i: Xoay<br>
            ‚Ä¢ Chu·ªôt ph·∫£i: Pan<br>
            ‚Ä¢ Scroll: Zoom
        </small>
    </div>

    <!-- Three.js ES6 Modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.158.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.158.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        let scene, camera, renderer, controls, model;
        let wireframe = false;
        let animationId;
        let lights = []; // L∆∞u tr·ªØ t·∫•t c·∫£ lights ƒë·ªÉ c√≥ th·ªÉ ƒëi·ªÅu ch·ªânh
        let superBrightMode = false;
        let originalMaterials = new Map(); // L∆∞u tr·ªØ m√†u g·ªëc c·ªßa materials
        let matcapMode = false;
        let normalMode = false;
        let contrastMode = false;
        let depthMode = false;
        
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(50, 50, 50);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2; // Gi·∫£m exposure ƒë·ªÉ tƒÉng t∆∞∆°ng ph·∫£n
            renderer.physicallyCorrectLights = true;
            // TƒÉng gamma ƒë·ªÉ l√†m n·ªïi b·∫≠t chi ti·∫øt
            renderer.gammaFactor = 2.2;
            document.body.appendChild(renderer.domElement);
            
            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            
            // Lights - Thi·∫øt l·∫≠p ƒë·ªÉ t·∫°o t∆∞∆°ng ph·∫£n t·ªët
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4); // Gi·∫£m ambient ƒë·ªÉ tƒÉng t∆∞∆°ng ph·∫£n
            scene.add(ambientLight);
            lights.push(ambientLight);
            
            // Key light - √Ånh s√°ng ch√≠nh t·ª´ g√≥c cao
            const keyLight = new THREE.DirectionalLight(0xffffff, 2.0);
            keyLight.position.set(100, 100, 50);
            keyLight.castShadow = true;
            keyLight.shadow.mapSize.width = 2048;
            keyLight.shadow.mapSize.height = 2048;
            keyLight.shadow.camera.near = 0.1;
            keyLight.shadow.camera.far = 500;
            keyLight.shadow.camera.left = -100;
            keyLight.shadow.camera.right = 100;
            keyLight.shadow.camera.top = 100;
            keyLight.shadow.camera.bottom = -100;
            scene.add(keyLight);
            lights.push(keyLight);
            
            // Fill light - √Ånh s√°ng ph·ª• ƒë·ªÉ l√†m m·ªÅm b√≥ng
            const fillLight = new THREE.DirectionalLight(0x7799ff, 0.6);
            fillLight.position.set(-50, 50, 50);
            scene.add(fillLight);
            lights.push(fillLight);
            
            // Rim light - √Ånh s√°ng vi·ªÅn ƒë·ªÉ t·∫°o ƒë·ªô s√¢u
            const rimLight = new THREE.DirectionalLight(0xffaa77, 0.8);
            rimLight.position.set(-100, -50, -100);
            scene.add(rimLight);
            lights.push(rimLight);
            
            // Bottom light - √Ånh s√°ng t·ª´ d∆∞·ªõi l√™n
            const bottomLight = new THREE.DirectionalLight(0x6666ff, 0.3);
            bottomLight.position.set(0, -100, 0);
            scene.add(bottomLight);
            lights.push(bottomLight);
            
            // Load GLB model
            const loader = new GLTFLoader();
            
            loader.load(
                '1_web.glb',
                function (gltf) {
                    model = gltf.scene;
                    
                    // C·∫£i thi·ªán material ƒë·ªÉ tƒÉng t∆∞∆°ng ph·∫£n v√† chi ti·∫øt
                    model.traverse(function (child) {
                        if (child.isMesh) {
                            if (child.material) {
                                // Clone material
                                child.material = child.material.clone();
                                
                                // L∆∞u tr·ªØ m√†u g·ªëc v√† c√°c thu·ªôc t√≠nh
                                if (child.material.color) {
                                    originalMaterials.set(child, {
                                        color: child.material.color.clone(),
                                        emissive: child.material.emissive ? child.material.emissive.clone() : new THREE.Color(0x000000),
                                        roughness: child.material.roughness || 0.5,
                                        metalness: child.material.metalness || 0.0,
                                        material: child.material.clone()
                                    });
                                }
                                
                                // T·ªëi ∆∞u cho t∆∞∆°ng ph·∫£n
                                if (child.material.roughness !== undefined) {
                                    child.material.roughness = 0.8; // TƒÉng roughness ƒë·ªÉ gi·∫£m ph·∫£n chi·∫øu
                                }
                                
                                if (child.material.metalness !== undefined) {
                                    child.material.metalness = 0.1; // Gi·∫£m metalness
                                }
                                
                                // Enable shadow
                                child.castShadow = true;
                                child.receiveShadow = true;
                                
                                // C·∫£i thi·ªán texture encoding
                                if (child.material.map) {
                                    child.material.map.encoding = THREE.sRGBEncoding;
                                }
                                
                                child.material.needsUpdate = true;
                            }
                        }
                    });
                    
                    // Scale model if needed
                    const box = new THREE.Box3().setFromObject(model);
                    const center = box.getCenter(new THREE.Vector3());
                    const size = box.getSize(new THREE.Vector3());
                    
                    // Center the model
                    model.position.sub(center);
                    
                    // Scale to reasonable size
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scale = 50 / maxDim;
                    model.scale.multiplyScalar(scale);
                    
                    scene.add(model);
                    
                    // Hide loading
                    document.getElementById('loading').style.display = 'none';
                    
                    console.log('Model loaded successfully');
                    console.log('Vertices:', gltf.scene.children.length);
                },
                function (progress) {
                    const percent = (progress.loaded / progress.total * 100).toFixed(1);
                    document.getElementById('loading').textContent = `ƒêang t·∫£i: ${percent}%`;
                },
                function (error) {
                    console.error('Error loading model:', error);
                    document.getElementById('loading').textContent = 'L·ªói t·∫£i model!';
                }
            );
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Start animation loop
            animate();
        }
        
        function animate() {
            animationId = requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function resetCamera() {
            controls.reset();
            camera.position.set(50, 50, 50);
        }
        
        function toggleWireframe() {
            if (!model) return;
            
            wireframe = !wireframe;
            model.traverse(function (child) {
                if (child.isMesh) {
                    child.material.wireframe = wireframe;
                }
            });
        }
        
        function toggleAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            } else {
                animate();
            }
        }
        
        function increaseBrightness() {
            lights.forEach(light => {
                if (light.intensity !== undefined) {
                    light.intensity = Math.min(light.intensity * 1.2, 5.0); // TƒÉng 20%, max 5.0
                }
            });
            console.log('Brightness increased');
        }
        
        function decreaseBrightness() {
            lights.forEach(light => {
                if (light.intensity !== undefined) {
                    light.intensity = Math.max(light.intensity * 0.8, 0.1); // Gi·∫£m 20%, min 0.1
                }
            });
            console.log('Brightness decreased');
        }
        
        function setBlackBackground() {
            scene.background = new THREE.Color(0x000000); // ƒêen
            console.log('Background set to black');
        }
        
        function setWhiteBackground() {
            scene.background = new THREE.Color(0xffffff); // Tr·∫Øng
            console.log('Background set to white');
        }
        
        function setGrayBackground() {
            scene.background = new THREE.Color(0x808080); // X√°m
            console.log('Background set to gray');
        }
        
        function toggleSuperBright() {
            superBrightMode = !superBrightMode;
            
            if (superBrightMode) {
                // Ch·∫ø ƒë·ªô si√™u s√°ng
                lights.forEach(light => {
                    if (light.intensity !== undefined) {
                        light.intensity *= 2.0; // TƒÉng g·∫•p ƒë√¥i
                    }
                });
                renderer.toneMappingExposure = 2.5; // TƒÉng exposure
                console.log('Super bright mode ON');
            } else {
                // Tr·ªü v·ªÅ b√¨nh th∆∞·ªùng
                lights.forEach(light => {
                    if (light.intensity !== undefined) {
                        light.intensity /= 2.0; // Gi·∫£m v·ªÅ b√¨nh th∆∞·ªùng
                    }
                });
                renderer.toneMappingExposure = 1.5; // V·ªÅ exposure b√¨nh th∆∞·ªùng
                console.log('Super bright mode OFF');
            }
        }
        
        function setModelColor(colorHex) {
            if (!model) return;
            
            const color = new THREE.Color(colorHex);
            
            model.traverse(function (child) {
                if (child.isMesh && child.material) {
                    // Thi·∫øt l·∫≠p m√†u m·ªõi
                    child.material.color.copy(color);
                    
                    // ƒêi·ªÅu ch·ªânh emissive ƒë·ªÉ m√†u s√°ng h∆°n
                    if (child.material.emissive) {
                        child.material.emissive.copy(color).multiplyScalar(0.1);
                    }
                    
                    child.material.needsUpdate = true;
                }
            });
            
            console.log(`Model color changed to: ${colorHex}`);
        }
        
        function resetModelColor() {
            if (!model) return;
            
            model.traverse(function (child) {
                if (child.isMesh && child.material && originalMaterials.has(child)) {
                    const original = originalMaterials.get(child);
                    
                    // Kh√¥i ph·ª•c m√†u g·ªëc
                    child.material.color.copy(original.color);
                    
                    if (child.material.emissive) {
                        child.material.emissive.copy(original.emissive);
                    }
                    
                    child.material.needsUpdate = true;
                }
            });
            
            console.log('Model color reset to original');
        }
        
        function toggleMatcap() {
            if (!model) return;
            
            matcapMode = !matcapMode;
            
            model.traverse(function (child) {
                if (child.isMesh && child.material) {
                    if (matcapMode) {
                        // T·∫°o matcap material ƒë∆°n gi·∫£n
                        const matcapMaterial = new THREE.MeshMatcapMaterial({
                            color: child.material.color || 0xffffff
                        });
                        child.material = matcapMaterial;
                    } else {
                        // Kh√¥i ph·ª•c material g·ªëc
                        if (originalMaterials.has(child)) {
                            child.material = originalMaterials.get(child).material.clone();
                        }
                    }
                    child.material.needsUpdate = true;
                }
            });
            
            console.log(`Matcap mode: ${matcapMode ? 'ON' : 'OFF'}`);
        }
        
        function toggleNormalMap() {
            if (!model) return;
            
            normalMode = !normalMode;
            
            model.traverse(function (child) {
                if (child.isMesh && child.material) {
                    if (normalMode) {
                        // T·∫°o material hi·ªÉn th·ªã normal
                        const normalMaterial = new THREE.MeshNormalMaterial();
                        child.material = normalMaterial;
                    } else {
                        // Kh√¥i ph·ª•c material g·ªëc
                        if (originalMaterials.has(child)) {
                            child.material = originalMaterials.get(child).material.clone();
                        }
                    }
                    child.material.needsUpdate = true;
                }
            });
            
            console.log(`Normal mode: ${normalMode ? 'ON' : 'OFF'}`);
        }
        
        function enhanceContrast() {
            if (!model) return;
            
            contrastMode = !contrastMode;
            
            if (contrastMode) {
                // TƒÉng c∆∞·ªùng t∆∞∆°ng ph·∫£n
                lights.forEach(light => {
                    if (light.intensity !== undefined) {
                        light.intensity *= 1.5;
                    }
                });
                
                // Gi·∫£m ambient light ƒë·ªÉ tƒÉng ƒë·ªô t∆∞∆°ng ph·∫£n
                lights[0].intensity = 0.2; // Ambient light
                
                renderer.toneMappingExposure = 0.8;
                
                model.traverse(function (child) {
                    if (child.isMesh && child.material) {
                        if (child.material.roughness !== undefined) {
                            child.material.roughness = 0.9;
                        }
                        child.material.needsUpdate = true;
                    }
                });
            } else {
                // Kh√¥i ph·ª•c b√¨nh th∆∞·ªùng
                lights.forEach(light => {
                    if (light.intensity !== undefined) {
                        light.intensity /= 1.5;
                    }
                });
                
                lights[0].intensity = 0.4; // Ambient light
                renderer.toneMappingExposure = 1.2;
                
                model.traverse(function (child) {
                    if (child.isMesh && child.material) {
                        if (child.material.roughness !== undefined) {
                            child.material.roughness = 0.8;
                        }
                        child.material.needsUpdate = true;
                    }
                });
            }
            
            console.log(`Contrast mode: ${contrastMode ? 'ON' : 'OFF'}`);
        }
        
        function toggleDepthShading() {
            if (!model) return;
            
            depthMode = !depthMode;
            
            model.traverse(function (child) {
                if (child.isMesh && child.material) {
                    if (depthMode) {
                        // T·∫°o material depth
                        const depthMaterial = new THREE.MeshDepthMaterial();
                        child.material = depthMaterial;
                    } else {
                        // Kh√¥i ph·ª•c material g·ªëc
                        if (originalMaterials.has(child)) {
                            child.material = originalMaterials.get(child).material.clone();
                        }
                    }
                    child.material.needsUpdate = true;
                }
            });
            
            console.log(`Depth mode: ${depthMode ? 'ON' : 'OFF'}`);
        }
        
        // Make functions global so they can be called from HTML
        window.resetCamera = resetCamera;
        window.toggleWireframe = toggleWireframe;
        window.toggleAnimation = toggleAnimation;
        window.increaseBrightness = increaseBrightness;
        window.decreaseBrightness = decreaseBrightness;
        window.setBlackBackground = setBlackBackground;
        window.setWhiteBackground = setWhiteBackground;
        window.setGrayBackground = setGrayBackground;
        window.toggleSuperBright = toggleSuperBright;
        window.setModelColor = setModelColor;
        window.resetModelColor = resetModelColor;
        window.toggleMatcap = toggleMatcap;
        window.toggleNormalMap = toggleNormalMap;
        window.enhanceContrast = enhanceContrast;
        window.toggleDepthShading = toggleDepthShading;
        
        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
